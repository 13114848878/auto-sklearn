.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_40_advanced_example_get_pipeline_components.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_examples_40_advanced_example_get_pipeline_components.py:


======================
Obtain run information
======================

The following example shows how to obtain information from a finished
Auto-sklearn run. In particular, it shows:
* how to query which models were evaluated by Auto-sklearn
* how to query the models in the final ensemble
* how to get general statistics on the what Auto-sklearn evaluated

Auto-sklearn is a wrapper on top of
the sklearn models. This example illustrates how to interact
with the sklearn components directly, in this case a PCA preprocessor.


.. code-block:: default

    import sklearn.datasets
    import sklearn.metrics

    import autosklearn.classification








Data Loading
============


.. code-block:: default


    X, y = sklearn.datasets.load_breast_cancer(return_X_y=True)
    X_train, X_test, y_train, y_test = \
        sklearn.model_selection.train_test_split(X, y, random_state=1)








Build and fit the classifier
============================


.. code-block:: default


    automl = autosklearn.classification.AutoSklearnClassifier(
        time_left_for_this_task=30,
        per_run_time_limit=10,
        disable_evaluator_output=False,
        # To simplify querying the models in the final ensemble, we
        # restrict auto-sklearn to use only pca as a preprocessor
        include_preprocessors=['pca'],
    )
    automl.fit(X_train, y_train, dataset_name='breast_cancer')





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    AutoSklearnClassifier(dask_client=None,
                          delete_output_folder_after_terminate=True,
                          delete_tmp_folder_after_terminate=True,
                          disable_evaluator_output=False,
                          ensemble_memory_limit=1024, ensemble_nbest=50,
                          ensemble_size=50, exclude_estimators=None,
                          exclude_preprocessors=None, get_smac_object_callback=None,
                          include_estimators=None, include_preprocessors=['pca'],
                          initial_configurations_via_metalearning=25,
                          logging_config=None, max_models_on_disc=50,
                          metadata_directory=None, metric=None,
                          ml_memory_limit=3072, n_jobs=None, output_folder=None,
                          per_run_time_limit=10, resampling_strategy='holdout',
                          resampling_strategy_arguments=None, seed=1,
                          smac_scenario_args=None, time_left_for_this_task=30,
                          tmp_folder=None)



Predict using the model
=======================


.. code-block:: default


    predictions = automl.predict(X_test)
    print("Accuracy score:{}".format(
        sklearn.metrics.accuracy_score(y_test, predictions))
    )






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Accuracy score:0.9440559440559441




Report the models found by Auto-Sklearn
=======================================

Auto-sklearn uses
`Ensemble Selection <https://www.cs.cornell.edu/~alexn/papers/shotgun.icml04.revised.rev2.pdf>`_
to construct ensembles in a post-hoc fashion. The ensemble is a linear
weighting of all models constructed during the hyperparameter optimization.
This prints the final ensemble. It is a list of tuples, each tuple being
the model weight in the ensemble and the model itself.


.. code-block:: default


    print(automl.show_models())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [(0.180000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.00029343005629408535, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.0006217675098852786, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.08644440750922357, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1272, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'feature_preprocessor:pca:keep_variance': 0.867157249218679, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.120000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'lda', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:lda:n_components': 31, 'classifier:lda:shrinkage': 'None', 'classifier:lda:tol': 0.0009761014302946388, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 524, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'feature_preprocessor:pca:keep_variance': 0.6868581390238322, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.120000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'adaboost', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME', 'classifier:adaboost:learning_rate': 1.4120696722366737, 'classifier:adaboost:max_depth': 8, 'classifier:adaboost:n_estimators': 489, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.011307840322412704, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.7357867136119712, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.2832469215827823, 'feature_preprocessor:pca:keep_variance': 0.99855313014133, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.100000, SimpleClassificationPipeline({'balancing:strategy': 'weighting', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.0005601203028935775, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.03814905685843504, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.37039167131337997, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.9016170587274669, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.21255575258712786, 'feature_preprocessor:pca:keep_variance': 0.8463779151982095, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.080000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'qda', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'minmax', 'feature_preprocessor:__choice__': 'pca', 'classifier:qda:reg_param': 0.9925689857743112, 'feature_preprocessor:pca:keep_variance': 0.6019614726104205, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.060000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'adaboost', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME', 'classifier:adaboost:learning_rate': 0.011233995624432622, 'classifier:adaboost:max_depth': 9, 'classifier:adaboost:n_estimators': 477, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.018370622484682127, 'feature_preprocessor:pca:keep_variance': 0.6039710338898471, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.040000, SimpleClassificationPipeline({'balancing:strategy': 'weighting', 'classifier:__choice__': 'qda', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:qda:reg_param': 0.30651727584804167, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.09969894798381888, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 406, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'normal', 'feature_preprocessor:pca:keep_variance': 0.5420039519254406, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.040000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'adaboost', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME', 'classifier:adaboost:learning_rate': 0.18616606702962551, 'classifier:adaboost:max_depth': 6, 'classifier:adaboost:n_estimators': 465, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 477, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'feature_preprocessor:pca:keep_variance': 0.9607871361087589, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.040000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 0.010450285658572039, 'classifier:bernoulli_nb:fit_prior': 'False', 'feature_preprocessor:pca:keep_variance': 0.71128231790029, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.040000, SimpleClassificationPipeline({'balancing:strategy': 'weighting', 'classifier:__choice__': 'decision_tree', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:decision_tree:criterion': 'gini', 'classifier:decision_tree:max_depth_factor': 0.6597665925206011, 'classifier:decision_tree:max_features': 1.0, 'classifier:decision_tree:max_leaf_nodes': 'None', 'classifier:decision_tree:min_impurity_decrease': 0.0, 'classifier:decision_tree:min_samples_leaf': 5, 'classifier:decision_tree:min_samples_split': 14, 'classifier:decision_tree:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.5366236015263764, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.040000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'decision_tree', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'normalize', 'feature_preprocessor:__choice__': 'pca', 'classifier:decision_tree:criterion': 'entropy', 'classifier:decision_tree:max_depth_factor': 0.06085025427372215, 'classifier:decision_tree:max_features': 1.0, 'classifier:decision_tree:max_leaf_nodes': 'None', 'classifier:decision_tree:min_impurity_decrease': 0.0, 'classifier:decision_tree:min_samples_leaf': 11, 'classifier:decision_tree:min_samples_split': 10, 'classifier:decision_tree:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.7901384229882784, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 3.296882955229148e-05, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.06342818423096075, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.001744501085113736, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.9340543650206188, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.08696626164646676, 'feature_preprocessor:pca:keep_variance': 0.8921349428944974, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'gradient_boosting', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:gradient_boosting:early_stop': 'valid', 'classifier:gradient_boosting:l2_regularization': 3.4923999567248705e-06, 'classifier:gradient_boosting:learning_rate': 0.2581292680846785, 'classifier:gradient_boosting:loss': 'auto', 'classifier:gradient_boosting:max_bins': 255, 'classifier:gradient_boosting:max_depth': 'None', 'classifier:gradient_boosting:max_leaf_nodes': 31, 'classifier:gradient_boosting:min_samples_leaf': 3, 'classifier:gradient_boosting:scoring': 'loss', 'classifier:gradient_boosting:tol': 1e-07, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1667, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'normal', 'feature_preprocessor:pca:keep_variance': 0.7039113060491162, 'feature_preprocessor:pca:whiten': 'False', 'classifier:gradient_boosting:n_iter_no_change': 10, 'classifier:gradient_boosting:validation_fraction': 0.027957987255057833},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 4.981721187342863, 'classifier:bernoulli_nb:fit_prior': 'True', 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.17246990240138507, 'feature_preprocessor:pca:keep_variance': 0.9270885897478363, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'True', 'classifier:random_forest:criterion': 'gini', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.5, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 1, 'classifier:random_forest:min_samples_split': 2, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01, 'feature_preprocessor:pca:keep_variance': 0.9999, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 15.858294393000183, 'classifier:bernoulli_nb:fit_prior': 'False', 'feature_preprocessor:pca:keep_variance': 0.8452918288007749, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'extra_trees', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:extra_trees:bootstrap': 'False', 'classifier:extra_trees:criterion': 'entropy', 'classifier:extra_trees:max_depth': 'None', 'classifier:extra_trees:max_features': 0.15474422799406629, 'classifier:extra_trees:max_leaf_nodes': 'None', 'classifier:extra_trees:min_impurity_decrease': 0.0, 'classifier:extra_trees:min_samples_leaf': 9, 'classifier:extra_trees:min_samples_split': 17, 'classifier:extra_trees:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.9672077981437592, 'feature_preprocessor:pca:whiten': 'False'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    (0.020000, SimpleClassificationPipeline({'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'False', 'classifier:random_forest:criterion': 'entropy', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.8935735777039215, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 6, 'classifier:random_forest:min_samples_split': 17, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.960749412053218, 'feature_preprocessor:pca:whiten': 'True'},
    dataset_properties={
      'task': 1,
      'sparse': False,
      'multilabel': False,
      'multiclass': False,
      'target_type': 'classification',
      'signed': False})),
    ]




Report statistics about the search
==================================

Print statistics about the auto-sklearn run such as number of
iterations, number of models failed with a time out etc.


.. code-block:: default

    print(automl.sprint_statistics())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    auto-sklearn results:
      Dataset name: breast_cancer
      Metric: accuracy
      Best validation score: 0.971631
      Number of target algorithm runs: 23
      Number of successful target algorithm runs: 23
      Number of crashed target algorithm runs: 0
      Number of target algorithms that exceeded the time limit: 0
      Number of target algorithms that exceeded the memory limit: 0





Detailed statistics about the search - part 1
=============================================

Auto-sklearn also keeps detailed statistics of the hyperparameter
optimization procedurce, which are stored in a so-called
`run history <https://automl.github.io/SMAC3/master/apidoc/smac.
runhistory.runhistory.html#smac.runhistory# .runhistory.RunHistory>`_.


.. code-block:: default


    print(automl.automl_.runhistory_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <smac.runhistory.runhistory.RunHistory object at 0x7fd6e169cc50>




Runs are stored inside an ``OrderedDict`` called ``data``:


.. code-block:: default


    print(len(automl.automl_.runhistory_.data))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    24




Let's iterative over all entries


.. code-block:: default


    for run_key in automl.automl_.runhistory_.data:
        print('#########')
        print(run_key)
        print(automl.automl_.runhistory_.data[run_key])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    #########
    RunKey(config_id=1, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.08510638297872342, time=1.0781984329223633, status=<StatusType.SUCCESS: 1>, starttime=1603146100.307766, endtime=1603146101.3971784, additional_info={'duration': 1.0322601795196533, 'num_run': 2, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=2, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.08510638297872342, time=0.21217036247253418, status=<StatusType.SUCCESS: 1>, starttime=1603146101.3996363, endtime=1603146101.622416, additional_info={'duration': 0.19002437591552734, 'num_run': 3, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=3, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.04255319148936165, time=0.2036571502685547, status=<StatusType.SUCCESS: 1>, starttime=1603146101.6237679, endtime=1603146101.8377306, additional_info={'duration': 0.18176960945129395, 'num_run': 4, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=4, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.028368794326241176, time=0.22718524932861328, status=<StatusType.SUCCESS: 1>, starttime=1603146103.4970322, endtime=1603146103.7352366, additional_info={'duration': 0.20427966117858887, 'num_run': 5, 'train_loss': 0.021052631578947323, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=5, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.06382978723404253, time=0.4314897060394287, status=<StatusType.SUCCESS: 1>, starttime=1603146105.5147083, endtime=1603146105.957406, additional_info={'duration': 0.4081881046295166, 'num_run': 6, 'train_loss': 0.0, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=6, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.04255319148936165, time=0.21140122413635254, status=<StatusType.SUCCESS: 1>, starttime=1603146105.9667249, endtime=1603146106.1893835, additional_info={'duration': 0.18893909454345703, 'num_run': 7, 'train_loss': 0.06315789473684208, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=7, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.1063829787234043, time=0.28036999702453613, status=<StatusType.SUCCESS: 1>, starttime=1603146106.198741, endtime=1603146106.4903114, additional_info={'duration': 0.2528715133666992, 'num_run': 8, 'train_loss': 0.14385964912280702, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=8, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.04255319148936165, time=0.3993234634399414, status=<StatusType.SUCCESS: 1>, starttime=1603146108.6023357, endtime=1603146109.0125458, additional_info={'duration': 0.3760495185852051, 'num_run': 9, 'train_loss': 0.06315789473684208, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=9, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.08510638297872342, time=0.21236467361450195, status=<StatusType.SUCCESS: 1>, starttime=1603146109.0242164, endtime=1603146109.2475505, additional_info={'duration': 0.18934249877929688, 'num_run': 10, 'train_loss': 0.08421052631578951, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=10, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07092198581560283, time=0.23456144332885742, status=<StatusType.SUCCESS: 1>, starttime=1603146109.2598438, endtime=1603146109.505535, additional_info={'duration': 0.21111178398132324, 'num_run': 11, 'train_loss': 0.0, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=11, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.08510638297872342, time=0.2775759696960449, status=<StatusType.SUCCESS: 1>, starttime=1603146109.519231, endtime=1603146109.8075535, additional_info={'duration': 0.25443053245544434, 'num_run': 12, 'train_loss': 0.09824561403508769, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=12, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.08510638297872342, time=0.719959020614624, status=<StatusType.SUCCESS: 1>, starttime=1603146109.821894, endtime=1603146110.5527177, additional_info={'duration': 0.6783847808837891, 'num_run': 13, 'train_loss': 0.10526315789473684, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=13, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.08510638297872342, time=0.3851499557495117, status=<StatusType.SUCCESS: 1>, starttime=1603146110.5739293, endtime=1603146110.9699683, additional_info={'duration': 0.35811567306518555, 'num_run': 14, 'train_loss': 0.08421052631578951, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=14, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07092198581560283, time=0.20723628997802734, status=<StatusType.SUCCESS: 1>, starttime=1603146110.9858997, endtime=1603146111.2040846, additional_info={'duration': 0.18441176414489746, 'num_run': 15, 'train_loss': 0.08771929824561409, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=15, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.12056737588652477, time=0.2156963348388672, status=<StatusType.SUCCESS: 1>, starttime=1603146111.2213306, endtime=1603146111.4479487, additional_info={'duration': 0.19246387481689453, 'num_run': 16, 'train_loss': 0.15438596491228074, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=16, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.03546099290780147, time=0.2899606227874756, status=<StatusType.SUCCESS: 1>, starttime=1603146111.466663, endtime=1603146111.7676897, additional_info={'duration': 0.2675435543060303, 'num_run': 17, 'train_loss': 0.09122807017543855, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=17, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.04255319148936165, time=0.22371315956115723, status=<StatusType.SUCCESS: 1>, starttime=1603146111.7870526, endtime=1603146112.021715, additional_info={'duration': 0.20108437538146973, 'num_run': 18, 'train_loss': 0.052631578947368474, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=18, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.11347517730496459, time=0.20520758628845215, status=<StatusType.SUCCESS: 1>, starttime=1603146112.0425825, endtime=1603146112.2586658, additional_info={'duration': 0.182725191116333, 'num_run': 19, 'train_loss': 0.08771929824561409, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=19, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07092198581560283, time=0.20741534233093262, status=<StatusType.SUCCESS: 1>, starttime=1603146112.2795506, endtime=1603146112.498132, additional_info={'duration': 0.18492507934570312, 'num_run': 20, 'train_loss': 0.08771929824561409, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=20, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07801418439716312, time=0.20572566986083984, status=<StatusType.SUCCESS: 1>, starttime=1603146112.520208, endtime=1603146112.7368517, additional_info={'duration': 0.18298554420471191, 'num_run': 21, 'train_loss': 0.08070175438596494, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=21, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.12056737588652477, time=0.9918227195739746, status=<StatusType.SUCCESS: 1>, starttime=1603146112.7590334, endtime=1603146113.7613668, additional_info={'duration': 0.9477448463439941, 'num_run': 22, 'train_loss': 0.07017543859649122, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=22, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.1063829787234043, time=0.2095930576324463, status=<StatusType.SUCCESS: 1>, starttime=1603146116.671172, endtime=1603146116.8912694, additional_info={'duration': 0.18651247024536133, 'num_run': 23, 'train_loss': 0.1333333333333333, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=23, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.09219858156028371, time=0.2056443691253662, status=<StatusType.SUCCESS: 1>, starttime=1603146116.916877, endtime=1603146117.133462, additional_info={'duration': 0.18139004707336426, 'num_run': 24, 'train_loss': 0.11228070175438598, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=24, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=2147483647.0, time=0.0, status=<StatusType.RUNNING: 9>, starttime=0.0, endtime=0.0, additional_info=None)




and have a detailed look at one entry:


.. code-block:: default


    run_key = list(automl.automl_.runhistory_.data.keys())[0]
    run_value = automl.automl_.runhistory_.data[run_key]








The ``run_key`` contains all information describing a run:


.. code-block:: default


    print("Configuration ID:", run_key.config_id)
    print("Instance:", run_key.instance_id)
    print("Seed:", run_key.seed)
    print("Budget:", run_key.budget)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Configuration ID: 1
    Instance: {"task_id": "breast_cancer"}
    Seed: 0
    Budget: 0.0




and the configuration can be looked up in the run history as well:


.. code-block:: default


    print(automl.automl_.runhistory_.ids_config[run_key.config_id])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Configuration:
      balancing:strategy, Value: 'none'
      classifier:__choice__, Value: 'random_forest'
      classifier:random_forest:bootstrap, Value: 'True'
      classifier:random_forest:criterion, Value: 'gini'
      classifier:random_forest:max_depth, Constant: 'None'
      classifier:random_forest:max_features, Value: 0.5
      classifier:random_forest:max_leaf_nodes, Constant: 'None'
      classifier:random_forest:min_impurity_decrease, Constant: 0.0
      classifier:random_forest:min_samples_leaf, Value: 1
      classifier:random_forest:min_samples_split, Value: 2
      classifier:random_forest:min_weight_fraction_leaf, Constant: 0.0
      data_preprocessing:categorical_transformer:categorical_encoding:__choice__, Value: 'one_hot_encoding'
      data_preprocessing:categorical_transformer:category_coalescence:__choice__, Value: 'minority_coalescer'
      data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction, Value: 0.01
      data_preprocessing:numerical_transformer:imputation:strategy, Value: 'mean'
      data_preprocessing:numerical_transformer:rescaling:__choice__, Value: 'standardize'
      feature_preprocessor:__choice__, Value: 'pca'
      feature_preprocessor:pca:keep_variance, Value: 0.9999
      feature_preprocessor:pca:whiten, Value: 'False'





The only other important entry is the budget in case you are using
auto-sklearn with
`successive halving <../60_search/example_successive_halving.html>`_.
The remaining parts of the key can be ignored for auto-sklearn and are
only there because the underlying optimizer, SMAC, can handle more general
problems, too.

The ``run_value`` contains all output from running the configuration:


.. code-block:: default


    print("Cost:", run_value.cost)
    print("Time:", run_value.time)
    print("Status:", run_value.status)
    print("Additional information:", run_value.additional_info)
    print("Start time:", run_value.starttime)
    print("End time", run_value.endtime)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Cost: 0.08510638297872342
    Time: 1.0781984329223633
    Status: StatusType.SUCCESS
    Additional information: {'duration': 1.0322601795196533, 'num_run': 2, 'train_loss': 0.0, 'configuration_origin': 'Initial design'}
    Start time: 1603146100.307766
    End time 1603146101.3971784




Cost is basically the same as a loss. In case the metric to optimize for
should be maximized, it is internally transformed into a minimization
metric. Additionally, the status type gives information on whether the run
was successful, while the additional information's most interesting entry
is the internal training loss. Furthermore, there is detailed information
on the runtime available.

As an example, let's find the best configuration evaluated. As
Auto-sklearn solves a minimization problem internally, we need to look
for the entry with the lowest loss:


.. code-block:: default


    losses_and_configurations = [
        (run_value.cost, run_key.config_id)
        for run_key, run_value in automl.automl_.runhistory_.data.items()
    ]
    losses_and_configurations.sort()
    print("Lowest loss:", losses_and_configurations[0][0])
    print(
        "Best configuration:",
        automl.automl_.runhistory_.ids_config[losses_and_configurations[0][1]]
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Lowest loss: 0.028368794326241176
    Best configuration: Configuration:
      balancing:strategy, Value: 'none'
      classifier:__choice__, Value: 'passive_aggressive'
      classifier:passive_aggressive:C, Value: 0.00029343005629408535
      classifier:passive_aggressive:average, Value: 'False'
      classifier:passive_aggressive:fit_intercept, Constant: 'True'
      classifier:passive_aggressive:loss, Value: 'squared_hinge'
      classifier:passive_aggressive:tol, Value: 0.0006217675098852786
      data_preprocessing:categorical_transformer:categorical_encoding:__choice__, Value: 'one_hot_encoding'
      data_preprocessing:categorical_transformer:category_coalescence:__choice__, Value: 'minority_coalescer'
      data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction, Value: 0.08644440750922357
      data_preprocessing:numerical_transformer:imputation:strategy, Value: 'median'
      data_preprocessing:numerical_transformer:rescaling:__choice__, Value: 'quantile_transformer'
      data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles, Value: 1272
      data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution, Value: 'uniform'
      feature_preprocessor:__choice__, Value: 'pca'
      feature_preprocessor:pca:keep_variance, Value: 0.867157249218679
      feature_preprocessor:pca:whiten, Value: 'True'





Detailed statistics about the search - part 2
=============================================

To maintain compatibility with scikit-learn, Auto-sklearn gives the
same data as
`cv_results_ <https://scikit-learn.org/stable/modules/generated/sklearn.
model_selection.GridSearchCV.html>`_.


.. code-block:: default


    print(automl.cv_results_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'mean_test_score': array([0.91489362, 0.91489362, 0.95744681, 0.97163121, 0.93617021,
           0.95744681, 0.89361702, 0.95744681, 0.91489362, 0.92907801,
           0.91489362, 0.91489362, 0.91489362, 0.92907801, 0.87943262,
           0.96453901, 0.95744681, 0.88652482, 0.92907801, 0.92198582,
           0.87943262, 0.89361702, 0.90780142]), 'mean_fit_time': array([1.07819843, 0.21217036, 0.20365715, 0.22718525, 0.43148971,
           0.21140122, 0.28037   , 0.39932346, 0.21236467, 0.23456144,
           0.27757597, 0.71995902, 0.38514996, 0.20723629, 0.21569633,
           0.28996062, 0.22371316, 0.20520759, 0.20741534, 0.20572567,
           0.99182272, 0.20959306, 0.20564437]), 'params': [{'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'True', 'classifier:random_forest:criterion': 'gini', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.5, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 1, 'classifier:random_forest:min_samples_split': 2, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01, 'feature_preprocessor:pca:keep_variance': 0.9999, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'adaboost', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME', 'classifier:adaboost:learning_rate': 1.4120696722366737, 'classifier:adaboost:max_depth': 8, 'classifier:adaboost:n_estimators': 489, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.011307840322412704, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.7357867136119712, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.2832469215827823, 'feature_preprocessor:pca:keep_variance': 0.99855313014133, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'adaboost', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME', 'classifier:adaboost:learning_rate': 0.011233995624432622, 'classifier:adaboost:max_depth': 9, 'classifier:adaboost:n_estimators': 477, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.018370622484682127, 'feature_preprocessor:pca:keep_variance': 0.6039710338898471, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.00029343005629408535, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.0006217675098852786, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.08644440750922357, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1272, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'feature_preprocessor:pca:keep_variance': 0.867157249218679, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'gradient_boosting', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:gradient_boosting:early_stop': 'valid', 'classifier:gradient_boosting:l2_regularization': 3.4923999567248705e-06, 'classifier:gradient_boosting:learning_rate': 0.2581292680846785, 'classifier:gradient_boosting:loss': 'auto', 'classifier:gradient_boosting:max_bins': 255, 'classifier:gradient_boosting:max_depth': 'None', 'classifier:gradient_boosting:max_leaf_nodes': 31, 'classifier:gradient_boosting:min_samples_leaf': 3, 'classifier:gradient_boosting:scoring': 'loss', 'classifier:gradient_boosting:tol': 1e-07, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1667, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'normal', 'feature_preprocessor:pca:keep_variance': 0.7039113060491162, 'feature_preprocessor:pca:whiten': 'False', 'classifier:gradient_boosting:n_iter_no_change': 10, 'classifier:gradient_boosting:validation_fraction': 0.027957987255057833}, {'balancing:strategy': 'none', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 3.296882955229148e-05, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.06342818423096075, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.001744501085113736, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.9340543650206188, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.08696626164646676, 'feature_preprocessor:pca:keep_variance': 0.8921349428944974, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 0.09719417527966989, 'classifier:bernoulli_nb:fit_prior': 'True', 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.00033859490560008565, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.8084581453922004, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.031748705344298564, 'feature_preprocessor:pca:keep_variance': 0.6987979712292358, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'qda', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:qda:reg_param': 0.30651727584804167, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.09969894798381888, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 406, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'normal', 'feature_preprocessor:pca:keep_variance': 0.5420039519254406, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 15.858294393000183, 'classifier:bernoulli_nb:fit_prior': 'False', 'feature_preprocessor:pca:keep_variance': 0.8452918288007749, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'adaboost', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:adaboost:algorithm': 'SAMME', 'classifier:adaboost:learning_rate': 0.18616606702962551, 'classifier:adaboost:max_depth': 6, 'classifier:adaboost:n_estimators': 465, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 477, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'feature_preprocessor:pca:keep_variance': 0.9607871361087589, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'decision_tree', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:decision_tree:criterion': 'gini', 'classifier:decision_tree:max_depth_factor': 0.6597665925206011, 'classifier:decision_tree:max_features': 1.0, 'classifier:decision_tree:max_leaf_nodes': 'None', 'classifier:decision_tree:min_impurity_decrease': 0.0, 'classifier:decision_tree:min_samples_leaf': 5, 'classifier:decision_tree:min_samples_split': 14, 'classifier:decision_tree:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.5366236015263764, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'extra_trees', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:extra_trees:bootstrap': 'False', 'classifier:extra_trees:criterion': 'entropy', 'classifier:extra_trees:max_depth': 'None', 'classifier:extra_trees:max_features': 0.15474422799406629, 'classifier:extra_trees:max_leaf_nodes': 'None', 'classifier:extra_trees:min_impurity_decrease': 0.0, 'classifier:extra_trees:min_samples_leaf': 9, 'classifier:extra_trees:min_samples_split': 17, 'classifier:extra_trees:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.9672077981437592, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 60.22206858077511, 'classifier:bernoulli_nb:fit_prior': 'True', 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.06683596080490382, 'feature_preprocessor:pca:keep_variance': 0.5482399813969581, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 0.010450285658572039, 'classifier:bernoulli_nb:fit_prior': 'False', 'feature_preprocessor:pca:keep_variance': 0.71128231790029, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.0035790207327275024, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'hinge', 'classifier:passive_aggressive:tol': 0.01742711517446636, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.062010489903396145, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.9607143894168919, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.10548959086192246, 'feature_preprocessor:pca:keep_variance': 0.6895794594676474, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.0005601203028935775, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.03814905685843504, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.37039167131337997, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.9016170587274669, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.21255575258712786, 'feature_preprocessor:pca:keep_variance': 0.8463779151982095, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'lda', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'feature_preprocessor:__choice__': 'pca', 'classifier:lda:n_components': 31, 'classifier:lda:shrinkage': 'None', 'classifier:lda:tol': 0.0009761014302946388, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 524, 'data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'feature_preprocessor:pca:keep_variance': 0.6868581390238322, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'qda', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'minmax', 'feature_preprocessor:__choice__': 'pca', 'classifier:qda:reg_param': 0.9925689857743112, 'feature_preprocessor:pca:keep_variance': 0.6019614726104205, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'bernoulli_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'standardize', 'feature_preprocessor:__choice__': 'pca', 'classifier:bernoulli_nb:alpha': 4.981721187342863, 'classifier:bernoulli_nb:fit_prior': 'True', 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.17246990240138507, 'feature_preprocessor:pca:keep_variance': 0.9270885897478363, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'gaussian_nb', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'minmax', 'feature_preprocessor:__choice__': 'pca', 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.013758513743274213, 'feature_preprocessor:pca:keep_variance': 0.740800515852948, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'none', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'False', 'classifier:random_forest:criterion': 'entropy', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.8935735777039215, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 6, 'classifier:random_forest:min_samples_split': 17, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.960749412053218, 'feature_preprocessor:pca:whiten': 'True'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'passive_aggressive', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessing:numerical_transformer:imputation:strategy': 'median', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'robust_scaler', 'feature_preprocessor:__choice__': 'pca', 'classifier:passive_aggressive:C': 0.0008066599153777725, 'classifier:passive_aggressive:average': 'False', 'classifier:passive_aggressive:fit_intercept': 'True', 'classifier:passive_aggressive:loss': 'squared_hinge', 'classifier:passive_aggressive:tol': 0.05239563326490216, 'data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.2844367515246698, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': 0.8773846581118605, 'data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': 0.14111639881074076, 'feature_preprocessor:pca:keep_variance': 0.6085115148399739, 'feature_preprocessor:pca:whiten': 'False'}, {'balancing:strategy': 'none', 'classifier:__choice__': 'decision_tree', 'data_preprocessing:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessing:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessing:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessing:numerical_transformer:rescaling:__choice__': 'normalize', 'feature_preprocessor:__choice__': 'pca', 'classifier:decision_tree:criterion': 'entropy', 'classifier:decision_tree:max_depth_factor': 0.06085025427372215, 'classifier:decision_tree:max_features': 1.0, 'classifier:decision_tree:max_leaf_nodes': 'None', 'classifier:decision_tree:min_impurity_decrease': 0.0, 'classifier:decision_tree:min_samples_leaf': 11, 'classifier:decision_tree:min_samples_split': 10, 'classifier:decision_tree:min_weight_fraction_leaf': 0.0, 'feature_preprocessor:pca:keep_variance': 0.7901384229882784, 'feature_preprocessor:pca:whiten': 'True'}], 'rank_test_scores': array([12, 12,  3,  1,  7,  3, 19,  3, 12,  8, 12, 12, 12,  8, 22,  2,  3,
           21,  8, 11, 22, 19, 18]), 'status': ['Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success'], 'budgets': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'param_balancing:strategy': masked_array(data=['none', 'none', 'none', 'none', 'none', 'none', 'none',
                       'weighting', 'none', 'none', 'weighting', 'none',
                       'weighting', 'none', 'none', 'weighting', 'none',
                       'none', 'none', 'none', 'none', 'none', 'none'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U9'), 'param_classifier:__choice__': masked_array(data=['random_forest', 'adaboost', 'adaboost',
                       'passive_aggressive', 'gradient_boosting',
                       'passive_aggressive', 'bernoulli_nb', 'qda',
                       'bernoulli_nb', 'adaboost', 'decision_tree',
                       'extra_trees', 'bernoulli_nb', 'bernoulli_nb',
                       'passive_aggressive', 'passive_aggressive', 'lda',
                       'qda', 'bernoulli_nb', 'gaussian_nb', 'random_forest',
                       'passive_aggressive', 'decision_tree'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U18'), 'param_data_preprocessing:categorical_transformer:categorical_encoding:__choice__': masked_array(data=['one_hot_encoding', 'no_encoding', 'no_encoding',
                       'one_hot_encoding', 'one_hot_encoding', 'no_encoding',
                       'no_encoding', 'no_encoding', 'no_encoding',
                       'one_hot_encoding', 'one_hot_encoding', 'no_encoding',
                       'one_hot_encoding', 'one_hot_encoding', 'no_encoding',
                       'no_encoding', 'one_hot_encoding', 'one_hot_encoding',
                       'no_encoding', 'one_hot_encoding', 'one_hot_encoding',
                       'one_hot_encoding', 'one_hot_encoding'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U16'), 'param_data_preprocessing:categorical_transformer:category_coalescence:__choice__': masked_array(data=['minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'minority_coalescer',
                       'no_coalescense', 'minority_coalescer',
                       'minority_coalescer', 'minority_coalescer',
                       'no_coalescense', 'no_coalescense', 'no_coalescense',
                       'no_coalescense', 'minority_coalescer',
                       'no_coalescense', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'no_coalescense', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'minority_coalescer', 'no_coalescense'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U18'), 'param_data_preprocessing:numerical_transformer:imputation:strategy': masked_array(data=['mean', 'mean', 'mean', 'median', 'mean', 'mean',
                       'mean', 'median', 'mean', 'most_frequent', 'mean',
                       'mean', 'median', 'mean', 'most_frequent',
                       'most_frequent', 'median', 'median', 'mean', 'median',
                       'most_frequent', 'median', 'mean'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U13'), 'param_data_preprocessing:numerical_transformer:rescaling:__choice__': masked_array(data=['standardize', 'robust_scaler', 'standardize',
                       'quantile_transformer', 'quantile_transformer',
                       'robust_scaler', 'robust_scaler',
                       'quantile_transformer', 'none', 'quantile_transformer',
                       'none', 'none', 'none', 'standardize', 'robust_scaler',
                       'robust_scaler', 'quantile_transformer', 'minmax',
                       'standardize', 'minmax', 'none', 'robust_scaler',
                       'normalize'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U20'), 'param_feature_preprocessor:__choice__': masked_array(data=['pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca',
                       'pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca',
                       'pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U3'), 'param_classifier:adaboost:algorithm': masked_array(data=[--, 'SAMME', 'SAMME', --, --, --, --, --, --, 'SAMME',
                       --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:adaboost:learning_rate': masked_array(data=[--, 1.4120696722366737, 0.011233995624432622, --, --,
                       --, --, --, --, 0.18616606702962551, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:adaboost:max_depth': masked_array(data=[--, 8.0, 9.0, --, --, --, --, --, --, 6.0, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:adaboost:n_estimators': masked_array(data=[--, 489.0, 477.0, --, --, --, --, --, --, 465.0, --,
                       --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:bernoulli_nb:alpha': masked_array(data=[--, --, --, --, --, --, 0.09719417527966989, --,
                       15.858294393000183, --, --, --, 60.22206858077511,
                       0.010450285658572039, --, --, --, --,
                       4.981721187342863, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True, False, False,  True,  True,
                        True,  True, False,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:bernoulli_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, 'True', --, 'False', --, --,
                       --, 'True', 'False', --, --, --, --, 'True', --, --,
                       --, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True,
                       False,  True,  True,  True, False, False,  True,  True,
                        True,  True, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:criterion': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 'gini', --, --,
                       --, --, --, --, --, --, --, --, --, 'entropy'],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:max_depth_factor': masked_array(data=[--, --, --, --, --, --, --, --, --, --,
                       0.6597665925206011, --, --, --, --, --, --, --, --, --,
                       --, --, 0.06085025427372215],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:max_features': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 1.0, --, --,
                       --, --, --, --, --, --, --, --, --, 1.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 'None', --, --,
                       --, --, --, --, --, --, --, --, --, 'None'],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 0.0, --, --,
                       --, --, --, --, --, --, --, --, --, 0.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 5.0, --, --,
                       --, --, --, --, --, --, --, --, --, 11.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 14.0, --, --,
                       --, --, --, --, --, --, --, --, --, 10.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, 0.0, --, --,
                       --, --, --, --, --, --, --, --, --, 0.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True, False,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:extra_trees:bootstrap': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 'False',
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:extra_trees:criterion': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 'entropy',
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:extra_trees:max_depth': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 'None', --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:extra_trees:max_features': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --,
                       0.15474422799406629, --, --, --, --, --, --, --, --,
                       --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:extra_trees:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 'None', --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:extra_trees:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 0.0, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:extra_trees:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 9.0, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:extra_trees:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 17.0, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:extra_trees:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, 0.0, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True, False,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:early_stop': masked_array(data=[--, --, --, --, 'valid', --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:gradient_boosting:l2_regularization': masked_array(data=[--, --, --, --, 3.4923999567248705e-06, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:learning_rate': masked_array(data=[--, --, --, --, 0.2581292680846785, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:loss': masked_array(data=[--, --, --, --, 'auto', --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:gradient_boosting:max_bins': masked_array(data=[--, --, --, --, 255.0, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:max_depth': masked_array(data=[--, --, --, --, 'None', --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:gradient_boosting:max_leaf_nodes': masked_array(data=[--, --, --, --, 31.0, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:min_samples_leaf': masked_array(data=[--, --, --, --, 3.0, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:scoring': masked_array(data=[--, --, --, --, 'loss', --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:gradient_boosting:tol': masked_array(data=[--, --, --, --, 1e-07, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:k_nearest_neighbors:n_neighbors': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:k_nearest_neighbors:p': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:k_nearest_neighbors:weights': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:lda:n_components': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, 31.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:lda:shrinkage': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, 'None', --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:lda:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, 0.0009761014302946388, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                       False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:C': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:dual': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:intercept_scaling': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:multi_class': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:penalty': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:liblinear_svc:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:C': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:gamma': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:kernel': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:max_iter': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:shrinking': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:passive_aggressive:C': masked_array(data=[--, --, --, 0.00029343005629408535, --,
                       3.296882955229148e-05, --, --, --, --, --, --, --, --,
                       0.0035790207327275024, 0.0005601203028935775, --, --,
                       --, --, --, 0.0008066599153777725, --],
                 mask=[ True,  True,  True, False,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20), 'param_classifier:passive_aggressive:average': masked_array(data=[--, --, --, 'False', --, 'False', --, --, --, --, --,
                       --, --, --, 'False', 'False', --, --, --, --, --,
                       'False', --],
                 mask=[ True,  True,  True, False,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:passive_aggressive:fit_intercept': masked_array(data=[--, --, --, 'True', --, 'True', --, --, --, --, --, --,
                       --, --, 'True', 'True', --, --, --, --, --, 'True', --],
                 mask=[ True,  True,  True, False,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:passive_aggressive:loss': masked_array(data=[--, --, --, 'squared_hinge', --, 'squared_hinge', --,
                       --, --, --, --, --, --, --, 'hinge', 'squared_hinge',
                       --, --, --, --, --, 'squared_hinge', --],
                 mask=[ True,  True,  True, False,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:passive_aggressive:tol': masked_array(data=[--, --, --, 0.0006217675098852786, --,
                       0.06342818423096075, --, --, --, --, --, --, --, --,
                       0.01742711517446636, 0.03814905685843504, --, --, --,
                       --, --, 0.05239563326490216, --],
                 mask=[ True,  True,  True, False,  True, False,  True,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20), 'param_classifier:qda:reg_param': masked_array(data=[--, --, --, --, --, --, --, 0.30651727584804167, --,
                       --, --, --, --, --, --, --, --, 0.9925689857743112, --,
                       --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:bootstrap': masked_array(data=['True', --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 'False', --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U5'), 'param_classifier:random_forest:criterion': masked_array(data=['gini', --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 'entropy', --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U7'), 'param_classifier:random_forest:max_depth': masked_array(data=['None', --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 'None', --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U4'), 'param_classifier:random_forest:max_features': masked_array(data=[0.5, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 0.8935735777039215, --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:max_leaf_nodes': masked_array(data=['None', --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 'None', --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U4'), 'param_classifier:random_forest:min_impurity_decrease': masked_array(data=[0.0, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 0.0, --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_samples_leaf': masked_array(data=[1.0, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 6.0, --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_samples_split': masked_array(data=[2.0, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 17.0, --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_weight_fraction_leaf': masked_array(data=[0.0, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, 0.0, --, --],
                 mask=[False,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:sgd:alpha': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:average': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:loss': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:penalty': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:tol': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessing:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': masked_array(data=[0.01, 0.011307840322412704, 0.018370622484682127,
                       0.08644440750922357, --, 0.001744501085113736,
                       0.00033859490560008565, 0.09969894798381888, --, --,
                       --, --, 0.06683596080490382, --, 0.062010489903396145,
                       0.37039167131337997, --, --, 0.17246990240138507,
                       0.013758513743274213, --, 0.2844367515246698, --],
                 mask=[False, False, False, False,  True, False, False, False,
                        True,  True,  True,  True, False,  True, False, False,
                        True,  True, False, False,  True, False,  True],
           fill_value=1e+20), 'param_data_preprocessing:numerical_transformer:rescaling:quantile_transformer:n_quantiles': masked_array(data=[--, --, --, 1272.0, 1667.0, --, --, 406.0, --, 477.0,
                       --, --, --, --, --, --, 524.0, --, --, --, --, --, --],
                 mask=[ True,  True,  True, False, False,  True,  True, False,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessing:numerical_transformer:rescaling:quantile_transformer:output_distribution': masked_array(data=[--, --, --, 'uniform', 'normal', --, --, 'normal', --,
                       'uniform', --, --, --, --, --, --, 'uniform', --, --,
                       --, --, --, --],
                 mask=[ True,  True,  True, False, False,  True,  True, False,
                        True, False,  True,  True,  True,  True,  True,  True,
                       False,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_max': masked_array(data=[--, 0.7357867136119712, --, --, --, 0.9340543650206188,
                       0.8084581453922004, --, --, --, --, --, --, --,
                       0.9607143894168919, 0.9016170587274669, --, --, --, --,
                       --, 0.8773846581118605, --],
                 mask=[ True, False,  True,  True,  True, False, False,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20), 'param_data_preprocessing:numerical_transformer:rescaling:robust_scaler:q_min': masked_array(data=[--, 0.2832469215827823, --, --, --,
                       0.08696626164646676, 0.031748705344298564, --, --, --,
                       --, --, --, --, 0.10548959086192246,
                       0.21255575258712786, --, --, --, --, --,
                       0.14111639881074076, --],
                 mask=[ True, False,  True,  True,  True, False, False,  True,
                        True,  True,  True,  True,  True,  True, False, False,
                        True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20), 'param_feature_preprocessor:pca:keep_variance': masked_array(data=[0.9999, 0.99855313014133, 0.6039710338898471,
                       0.867157249218679, 0.7039113060491162,
                       0.8921349428944974, 0.6987979712292358,
                       0.5420039519254406, 0.8452918288007749,
                       0.9607871361087589, 0.5366236015263764,
                       0.9672077981437592, 0.5482399813969581,
                       0.71128231790029, 0.6895794594676474,
                       0.8463779151982095, 0.6868581390238322,
                       0.6019614726104205, 0.9270885897478363,
                       0.740800515852948, 0.960749412053218,
                       0.6085115148399739, 0.7901384229882784],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value=1e+20), 'param_feature_preprocessor:pca:whiten': masked_array(data=['False', 'True', 'False', 'True', 'False', 'False',
                       'False', 'False', 'True', 'True', 'False', 'False',
                       'True', 'True', 'True', 'True', 'True', 'True',
                       'False', 'True', 'True', 'False', 'True'],
                 mask=[False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False, False,
                       False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U5'), 'param_classifier:gradient_boosting:n_iter_no_change': masked_array(data=[--, --, --, --, 10.0, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:gradient_boosting:validation_fraction': masked_array(data=[--, --, --, --, 0.027957987255057833, --, --, --, --,
                       --, --, --, --, --, --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:lda:shrinkage_factor': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:coef0': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:degree': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:epsilon': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:eta0': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:l1_ratio': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:power_t': masked_array(data=[--, --, --, --, --, --, --, --, --, --, --, --, --, --,
                       --, --, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True,  True,
                        True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64)}




Inspect the components of the best model
========================================

Iterate over the components of the model and print
The explained variance ratio per stage


.. code-block:: default

    for i, (weight, pipeline) in enumerate(automl.get_models_with_weights()):
        for stage_name, component in pipeline.named_steps.items():
            if 'preprocessor' in stage_name:
                print(
                    "The {}th pipeline has a explained variance of {}".format(
                        i,
                        # The component is an instance of AutoSklearnChoice.
                        # Access the sklearn object via the choice attribute
                        # We want the explained variance attributed of
                        # each principal component
                        component.choice.preprocessor.explained_variance_ratio_
                    )
                )




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The 0th pipeline has a explained variance of [0.45954161 0.18012095 0.09808836 0.06332952 0.05871665 0.03690454]
    The 1th pipeline has a explained variance of [0.45954161 0.18012095 0.09808836]
    The 2th pipeline has a explained variance of [6.86302645e-01 1.25544258e-01 9.02100053e-02 6.19996042e-02
     1.45735150e-02 6.43944771e-03 4.53221101e-03 3.18708698e-03
     1.95256209e-03 1.57315864e-03 1.32456937e-03 7.57120105e-04
     4.44789943e-04]
    The 3th pipeline has a explained variance of [0.71452021 0.11214084 0.08017173]
    The 4th pipeline has a explained variance of [0.49503611 0.16649281]
    The 5th pipeline has a explained variance of [0.43295688 0.1790573 ]
    The 6th pipeline has a explained variance of [0.46038756 0.1612497 ]
    The 7th pipeline has a explained variance of [0.45954161 0.18012095 0.09808836 0.06332952 0.05871665 0.03690454
     0.02471378 0.01657787 0.01327718 0.01023424]
    The 8th pipeline has a explained variance of [0.43295688 0.1790573  0.11173757]
    The 9th pipeline has a explained variance of [0.98080571]
    The 10th pipeline has a explained variance of [0.76699224 0.17152095]
    The 11th pipeline has a explained variance of [0.73309629 0.11704459 0.06917562]
    The 12th pipeline has a explained variance of [0.46038756 0.1612497  0.09747656]
    The 13th pipeline has a explained variance of [0.43295688 0.1790573  0.11173757 0.06807243 0.05946115 0.03706299
     0.0238431  0.01493261]
    The 14th pipeline has a explained variance of [4.32956881e-01 1.79057296e-01 1.11737571e-01 6.80724345e-02
     5.94611519e-02 3.70629898e-02 2.38430977e-02 1.49326086e-02
     1.37641366e-02 1.13704890e-02 1.03737258e-02 8.74116751e-03
     7.57629717e-03 4.86528503e-03 3.32225143e-03 2.55773043e-03
     2.20759805e-03 1.88675402e-03 1.36245140e-03 1.03409213e-03
     8.39749085e-04 7.91287172e-04 6.75655689e-04 5.42961621e-04
     5.02641737e-04 2.07827509e-04 1.74597367e-04]
    The 15th pipeline has a explained variance of [0.98080571]
    The 16th pipeline has a explained variance of [0.98080571]
    The 17th pipeline has a explained variance of [0.98080571]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  24.881 seconds)


.. _sphx_glr_download_examples_40_advanced_example_get_pipeline_components.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: example_get_pipeline_components.py <example_get_pipeline_components.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: example_get_pipeline_components.ipynb <example_get_pipeline_components.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
